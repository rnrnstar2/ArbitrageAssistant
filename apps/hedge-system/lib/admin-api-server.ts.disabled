import express from 'express';
import cors from 'cors';
import { WebSocketHandler } from './websocket-handler';
import { RealtimeStateManager } from './realtime-state-manager';
import Database from 'better-sqlite3';
import path from 'path';

interface TradeCommand {
  id: string;
  type: 'ENTRY' | 'CLOSE';
  accountId: string;
  symbol: string;
  direction?: 'buy' | 'sell';
  volume?: number;
  price?: number;
  timestamp: Date;
}

interface AdminAPIResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
  timestamp: Date;
}

/**
 * Hedge Systemå†…ã®Adminç”¨HTTP APIã‚µãƒ¼ãƒãƒ¼
 * Admin Webã‚¢ãƒ—ãƒªã‹ã‚‰ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†
 */
export class AdminAPIServer {
  private app: express.Application;
  private server?: any;
  private db: Database.Database;
  private wsHandler: WebSocketHandler;
  private stateManager: RealtimeStateManager;
  
  constructor(wsHandler: WebSocketHandler, stateManager: RealtimeStateManager) {
    this.wsHandler = wsHandler;
    this.stateManager = stateManager;
    
    // SQLiteåˆæœŸåŒ–
    this.initializeDatabase();
    
    // Expressè¨­å®š
    this.app = express();
    this.app.use(cors());
    this.app.use(express.json());
    
    this.setupRoutes();
  }
  
  /**
   * SQLiteãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–
   */
  private initializeDatabase(): void {
    const dbPath = path.join(process.cwd(), 'data', 'hedge-data.db');
    this.db = new Database(dbPath);
    
    // ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS positions (
        id TEXT PRIMARY KEY,
        accountId TEXT NOT NULL,
        mtPositionId TEXT NOT NULL,
        symbol TEXT NOT NULL,
        type TEXT NOT NULL,
        volume REAL NOT NULL,
        openPrice REAL NOT NULL,
        openTime TEXT NOT NULL,
        lastSync TEXT NOT NULL,
        isActive INTEGER DEFAULT 1,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP
      );
      
      CREATE TABLE IF NOT EXISTS accounts (
        id TEXT PRIMARY KEY,
        balance REAL NOT NULL,
        equity REAL NOT NULL,
        margin REAL NOT NULL,
        freeMargin REAL NOT NULL,
        marginLevel REAL NOT NULL,
        connectionStatus TEXT NOT NULL,
        lastUpdate TEXT NOT NULL
      );
      
      CREATE TABLE IF NOT EXISTS trade_commands (
        id TEXT PRIMARY KEY,
        type TEXT NOT NULL,
        accountId TEXT NOT NULL,
        symbol TEXT NOT NULL,
        direction TEXT,
        volume REAL,
        price REAL,
        status TEXT DEFAULT 'pending',
        result TEXT,
        timestamp TEXT NOT NULL,
        executedAt TEXT
      );
      
      CREATE TABLE IF NOT EXISTS completed_trades (
        id TEXT PRIMARY KEY,
        accountId TEXT NOT NULL,
        symbol TEXT NOT NULL,
        type TEXT NOT NULL,
        volume REAL NOT NULL,
        openPrice REAL NOT NULL,
        closePrice REAL,
        profit REAL,
        openTime TEXT NOT NULL,
        closeTime TEXT,
        synced INTEGER DEFAULT 0
      );
    `);
    
    console.log('ğŸ“Š SQLite database initialized');
  }
  
  /**
   * APIãƒ«ãƒ¼ãƒˆè¨­å®š
   */
  private setupRoutes(): void {
    // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
    this.app.get('/api/health', (req, res) => {
      res.json(this.createResponse(true, {
        status: 'healthy',
        uptime: process.uptime(),
        connections: this.wsHandler.getConnectedClients().length
      }));
    });
    
    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿å–å¾—
    this.app.get('/api/realtime', (req, res) => {
      try {
        const positions = this.stateManager.getAllPositions();
        const accounts = this.stateManager.getAllAccounts();
        const connections = this.stateManager.getConnectionStatus();
        
        res.json(this.createResponse(true, {
          positions,
          accounts,
          connections,
          lastUpdate: new Date()
        }));
      } catch (error) {
        console.error('âŒ Failed to get realtime data:', error);
        res.status(500).json(this.createResponse(false, null, 'Failed to get realtime data'));
      }
    });
    
    // ç‰¹å®šã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ãƒ‡ãƒ¼ã‚¿å–å¾—
    this.app.get('/api/accounts/:accountId', (req, res) => {
      try {
        const { accountId } = req.params;
        const account = this.stateManager.getAccount(accountId);
        const positions = this.stateManager.getPositionsByAccount(accountId);
        
        if (!account) {
          return res.status(404).json(this.createResponse(false, null, 'Account not found'));
        }
        
        res.json(this.createResponse(true, {
          account,
          positions
        }));
      } catch (error) {
        console.error('âŒ Failed to get account data:', error);
        res.status(500).json(this.createResponse(false, null, 'Failed to get account data'));
      }
    });
    
    // å–å¼•æŒ‡ä»¤å®Ÿè¡Œ
    this.app.post('/api/command', async (req, res) => {
      try {
        const command: TradeCommand = {
          ...req.body,
          id: req.body.id || `cmd_${Date.now()}`,
          timestamp: new Date()
        };
        
        // WebSocketã§EAã«é€ä¿¡
        const success = await this.wsHandler.sendTradeCommand(command.accountId, {
          action: command.type.toLowerCase() as 'open' | 'close',
          symbol: command.symbol,
          volume: command.volume || 0,
          type: command.direction || 'buy',
          price: command.price
        });
        
        // SQLiteã«è¨˜éŒ²
        const stmt = this.db.prepare(`
          INSERT INTO trade_commands (id, type, accountId, symbol, direction, volume, price, status, timestamp)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);
        
        stmt.run(
          command.id,
          command.type,
          command.accountId,
          command.symbol,
          command.direction,
          command.volume,
          command.price,
          success ? 'sent' : 'failed',
          command.timestamp.toISOString()
        );
        
        res.json(this.createResponse(success, { commandId: command.id }));
        
      } catch (error) {
        console.error('âŒ Failed to execute command:', error);
        res.status(500).json(this.createResponse(false, null, 'Failed to execute command'));
      }
    });
    
    // å–å¼•å±¥æ­´å–å¾—
    this.app.get('/api/history', (req, res) => {
      try {
        const { accountId, symbol, limit = 100 } = req.query;
        
        let query = 'SELECT * FROM completed_trades WHERE 1=1';
        const params: any[] = [];
        
        if (accountId) {
          query += ' AND accountId = ?';
          params.push(accountId);
        }
        
        if (symbol) {
          query += ' AND symbol = ?';
          params.push(symbol);
        }
        
        query += ' ORDER BY closeTime DESC LIMIT ?';
        params.push(Number(limit));
        
        const trades = this.db.prepare(query).all(...params);
        
        res.json(this.createResponse(true, { trades }));
      } catch (error) {
        console.error('âŒ Failed to get history:', error);
        res.status(500).json(this.createResponse(false, null, 'Failed to get history'));
      }
    });
    
    // çµ±è¨ˆãƒ‡ãƒ¼ã‚¿å–å¾—
    this.app.get('/api/stats', (req, res) => {
      try {
        const stats = {
          totalPositions: this.stateManager.getAllPositions().length,
          activeAccounts: this.stateManager.getAllAccounts().filter(a => a.connectionStatus === 'connected').length,
          totalAccounts: this.stateManager.getAllAccounts().length,
          wsConnections: this.wsHandler.getConnectedClients().length,
          wsStats: this.wsHandler.getStats()
        };
        
        res.json(this.createResponse(true, stats));
      } catch (error) {
        console.error('âŒ Failed to get stats:', error);
        res.status(500).json(this.createResponse(false, null, 'Failed to get stats'));
      }
    });
  }
  
  /**
   * ãƒã‚¸ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’SQLiteã«ä¿å­˜
   */
  savePosition(position: any): void {
    try {
      const stmt = this.db.prepare(`
        INSERT OR REPLACE INTO positions 
        (id, accountId, mtPositionId, symbol, type, volume, openPrice, openTime, lastSync, isActive)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);
      
      stmt.run(
        position.id,
        position.accountId,
        position.mtPositionId || position.id,
        position.symbol,
        position.type,
        position.volume,
        position.openPrice,
        position.openTime.toISOString(),
        new Date().toISOString(),
        position.isActive ? 1 : 0
      );
    } catch (error) {
      console.error('âŒ Failed to save position:', error);
    }
  }
  
  /**
   * ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæƒ…å ±ã‚’SQLiteã«ä¿å­˜
   */
  saveAccount(account: any): void {
    try {
      const stmt = this.db.prepare(`
        INSERT OR REPLACE INTO accounts 
        (id, balance, equity, margin, freeMargin, marginLevel, connectionStatus, lastUpdate)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `);
      
      stmt.run(
        account.id,
        account.balance,
        account.equity,
        account.margin,
        account.freeMargin,
        account.marginLevel,
        account.connectionStatus,
        new Date().toISOString()
      );
    } catch (error) {
      console.error('âŒ Failed to save account:', error);
    }
  }
  
  /**
   * ãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”Ÿæˆãƒ˜ãƒ«ãƒ‘ãƒ¼
   */
  private createResponse<T>(success: boolean, data?: T, error?: string): AdminAPIResponse<T> {
    return {
      success,
      data,
      error,
      timestamp: new Date()
    };
  }
  
  /**
   * ã‚µãƒ¼ãƒãƒ¼é–‹å§‹
   */
  async start(port: number = 3001): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        this.server = this.app.listen(port, () => {
          console.log(`ğŸš€ Admin API Server started on port ${port}`);
          resolve();
        });
      } catch (error) {
        console.error('âŒ Failed to start Admin API Server:', error);
        reject(error);
      }
    });
  }
  
  /**
   * ã‚µãƒ¼ãƒãƒ¼åœæ­¢
   */
  async stop(): Promise<void> {
    return new Promise((resolve) => {
      if (this.server) {
        this.server.close(() => {
          console.log('âœ… Admin API Server stopped');
          this.db.close();
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
}