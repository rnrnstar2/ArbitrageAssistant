import express from 'express';
import cors from 'cors';
import { WebSocketHandler } from './websocket-handler';
import { RealtimeStateManager } from './realtime-state-manager';
import Database from 'better-sqlite3';
import path from 'path';

interface TradeCommand {
  id: string;
  type: 'ENTRY' | 'CLOSE';
  accountId: string;
  symbol: string;
  direction?: 'buy' | 'sell';
  volume?: number;
  price?: number;
  timestamp: Date;
}

interface AdminAPIResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
  timestamp: Date;
}

/**
 * Hedge System内のAdmin用HTTP APIサーバー
 * Admin Webアプリからのリクエストを処理
 */
export class AdminAPIServer {
  private app: express.Application;
  private server?: any;
  private db: Database.Database;
  private wsHandler: WebSocketHandler;
  private stateManager: RealtimeStateManager;
  
  constructor(wsHandler: WebSocketHandler, stateManager: RealtimeStateManager) {
    this.wsHandler = wsHandler;
    this.stateManager = stateManager;
    
    // SQLite初期化
    this.initializeDatabase();
    
    // Express設定
    this.app = express();
    this.app.use(cors());
    this.app.use(express.json());
    
    this.setupRoutes();
  }
  
  /**
   * SQLiteデータベース初期化
   */
  private initializeDatabase(): void {
    const dbPath = path.join(process.cwd(), 'data', 'hedge-data.db');
    this.db = new Database(dbPath);
    
    // テーブル作成
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS positions (
        id TEXT PRIMARY KEY,
        accountId TEXT NOT NULL,
        mtPositionId TEXT NOT NULL,
        symbol TEXT NOT NULL,
        type TEXT NOT NULL,
        volume REAL NOT NULL,
        openPrice REAL NOT NULL,
        openTime TEXT NOT NULL,
        lastSync TEXT NOT NULL,
        isActive INTEGER DEFAULT 1,
        createdAt TEXT DEFAULT CURRENT_TIMESTAMP
      );
      
      CREATE TABLE IF NOT EXISTS accounts (
        id TEXT PRIMARY KEY,
        balance REAL NOT NULL,
        equity REAL NOT NULL,
        margin REAL NOT NULL,
        freeMargin REAL NOT NULL,
        marginLevel REAL NOT NULL,
        connectionStatus TEXT NOT NULL,
        lastUpdate TEXT NOT NULL
      );
      
      CREATE TABLE IF NOT EXISTS trade_commands (
        id TEXT PRIMARY KEY,
        type TEXT NOT NULL,
        accountId TEXT NOT NULL,
        symbol TEXT NOT NULL,
        direction TEXT,
        volume REAL,
        price REAL,
        status TEXT DEFAULT 'pending',
        result TEXT,
        timestamp TEXT NOT NULL,
        executedAt TEXT
      );
      
      CREATE TABLE IF NOT EXISTS completed_trades (
        id TEXT PRIMARY KEY,
        accountId TEXT NOT NULL,
        symbol TEXT NOT NULL,
        type TEXT NOT NULL,
        volume REAL NOT NULL,
        openPrice REAL NOT NULL,
        closePrice REAL,
        profit REAL,
        openTime TEXT NOT NULL,
        closeTime TEXT,
        synced INTEGER DEFAULT 0
      );
    `);
    
    console.log('📊 SQLite database initialized');
  }
  
  /**
   * APIルート設定
   */
  private setupRoutes(): void {
    // ヘルスチェック
    this.app.get('/api/health', (req, res) => {
      res.json(this.createResponse(true, {
        status: 'healthy',
        uptime: process.uptime(),
        connections: this.wsHandler.getConnectedClients().length
      }));
    });
    
    // リアルタイムデータ取得
    this.app.get('/api/realtime', (req, res) => {
      try {
        const positions = this.stateManager.getAllPositions();
        const accounts = this.stateManager.getAllAccounts();
        const connections = this.stateManager.getConnectionStatus();
        
        res.json(this.createResponse(true, {
          positions,
          accounts,
          connections,
          lastUpdate: new Date()
        }));
      } catch (error) {
        console.error('❌ Failed to get realtime data:', error);
        res.status(500).json(this.createResponse(false, null, 'Failed to get realtime data'));
      }
    });
    
    // 特定アカウントのデータ取得
    this.app.get('/api/accounts/:accountId', (req, res) => {
      try {
        const { accountId } = req.params;
        const account = this.stateManager.getAccount(accountId);
        const positions = this.stateManager.getPositionsByAccount(accountId);
        
        if (!account) {
          return res.status(404).json(this.createResponse(false, null, 'Account not found'));
        }
        
        res.json(this.createResponse(true, {
          account,
          positions
        }));
      } catch (error) {
        console.error('❌ Failed to get account data:', error);
        res.status(500).json(this.createResponse(false, null, 'Failed to get account data'));
      }
    });
    
    // 取引指令実行
    this.app.post('/api/command', async (req, res) => {
      try {
        const command: TradeCommand = {
          ...req.body,
          id: req.body.id || `cmd_${Date.now()}`,
          timestamp: new Date()
        };
        
        // WebSocketでEAに送信
        const success = await this.wsHandler.sendTradeCommand(command.accountId, {
          action: command.type.toLowerCase() as 'open' | 'close',
          symbol: command.symbol,
          volume: command.volume || 0,
          type: command.direction || 'buy',
          price: command.price
        });
        
        // SQLiteに記録
        const stmt = this.db.prepare(`
          INSERT INTO trade_commands (id, type, accountId, symbol, direction, volume, price, status, timestamp)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);
        
        stmt.run(
          command.id,
          command.type,
          command.accountId,
          command.symbol,
          command.direction,
          command.volume,
          command.price,
          success ? 'sent' : 'failed',
          command.timestamp.toISOString()
        );
        
        res.json(this.createResponse(success, { commandId: command.id }));
        
      } catch (error) {
        console.error('❌ Failed to execute command:', error);
        res.status(500).json(this.createResponse(false, null, 'Failed to execute command'));
      }
    });
    
    // 取引履歴取得
    this.app.get('/api/history', (req, res) => {
      try {
        const { accountId, symbol, limit = 100 } = req.query;
        
        let query = 'SELECT * FROM completed_trades WHERE 1=1';
        const params: any[] = [];
        
        if (accountId) {
          query += ' AND accountId = ?';
          params.push(accountId);
        }
        
        if (symbol) {
          query += ' AND symbol = ?';
          params.push(symbol);
        }
        
        query += ' ORDER BY closeTime DESC LIMIT ?';
        params.push(Number(limit));
        
        const trades = this.db.prepare(query).all(...params);
        
        res.json(this.createResponse(true, { trades }));
      } catch (error) {
        console.error('❌ Failed to get history:', error);
        res.status(500).json(this.createResponse(false, null, 'Failed to get history'));
      }
    });
    
    // 統計データ取得
    this.app.get('/api/stats', (req, res) => {
      try {
        const stats = {
          totalPositions: this.stateManager.getAllPositions().length,
          activeAccounts: this.stateManager.getAllAccounts().filter(a => a.connectionStatus === 'connected').length,
          totalAccounts: this.stateManager.getAllAccounts().length,
          wsConnections: this.wsHandler.getConnectedClients().length,
          wsStats: this.wsHandler.getStats()
        };
        
        res.json(this.createResponse(true, stats));
      } catch (error) {
        console.error('❌ Failed to get stats:', error);
        res.status(500).json(this.createResponse(false, null, 'Failed to get stats'));
      }
    });
  }
  
  /**
   * ポジション情報をSQLiteに保存
   */
  savePosition(position: any): void {
    try {
      const stmt = this.db.prepare(`
        INSERT OR REPLACE INTO positions 
        (id, accountId, mtPositionId, symbol, type, volume, openPrice, openTime, lastSync, isActive)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);
      
      stmt.run(
        position.id,
        position.accountId,
        position.mtPositionId || position.id,
        position.symbol,
        position.type,
        position.volume,
        position.openPrice,
        position.openTime.toISOString(),
        new Date().toISOString(),
        position.isActive ? 1 : 0
      );
    } catch (error) {
      console.error('❌ Failed to save position:', error);
    }
  }
  
  /**
   * アカウント情報をSQLiteに保存
   */
  saveAccount(account: any): void {
    try {
      const stmt = this.db.prepare(`
        INSERT OR REPLACE INTO accounts 
        (id, balance, equity, margin, freeMargin, marginLevel, connectionStatus, lastUpdate)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `);
      
      stmt.run(
        account.id,
        account.balance,
        account.equity,
        account.margin,
        account.freeMargin,
        account.marginLevel,
        account.connectionStatus,
        new Date().toISOString()
      );
    } catch (error) {
      console.error('❌ Failed to save account:', error);
    }
  }
  
  /**
   * レスポンス生成ヘルパー
   */
  private createResponse<T>(success: boolean, data?: T, error?: string): AdminAPIResponse<T> {
    return {
      success,
      data,
      error,
      timestamp: new Date()
    };
  }
  
  /**
   * サーバー開始
   */
  async start(port: number = 3001): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        this.server = this.app.listen(port, () => {
          console.log(`🚀 Admin API Server started on port ${port}`);
          resolve();
        });
      } catch (error) {
        console.error('❌ Failed to start Admin API Server:', error);
        reject(error);
      }
    });
  }
  
  /**
   * サーバー停止
   */
  async stop(): Promise<void> {
    return new Promise((resolve) => {
      if (this.server) {
        this.server.close(() => {
          console.log('✅ Admin API Server stopped');
          this.db.close();
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
}