import {
  IAlertManager,
  Alert,
  AlertConfig,
  AlertType,
  ConnectionMetrics,
  NotificationChannel,
  MONITORING_CONSTANTS,
} from './types';

export class AlertManager implements IAlertManager {
  private config: AlertConfig;
  private activeAlerts = new Map<string, Alert>();
  private alertHistory: Alert[] = [];
  private alertCooldowns = new Map<string, number>();
  
  constructor(config?: Partial<AlertConfig>) {
    this.config = this.createDefaultConfig(config);
  }
  
  private createDefaultConfig(config?: Partial<AlertConfig>): AlertConfig {
    return {
      latencyThreshold: config?.latencyThreshold || MONITORING_CONSTANTS.DEFAULT_LATENCY_THRESHOLD,
      errorRateThreshold: config?.errorRateThreshold || MONITORING_CONSTANTS.DEFAULT_ERROR_RATE_THRESHOLD,
      connectionStabilityThreshold: config?.connectionStabilityThreshold || MONITORING_CONSTANTS.DEFAULT_STABILITY_THRESHOLD,
      throughputMinThreshold: config?.throughputMinThreshold || MONITORING_CONSTANTS.DEFAULT_THROUGHPUT_THRESHOLD,
      enabled: config?.enabled ?? true,
      notificationChannels: config?.notificationChannels || ['log'],
    };
  }
  
  checkAlertConditions(metrics: ConnectionMetrics): Alert[] {
    if (!this.config.enabled) {
      return [];
    }
    
    const alerts: Alert[] = [];
    const now = Date.now();
    
    // „É¨„Ç§„ÉÜ„É≥„Ç∑„Ç¢„É©„Éº„Éà
    if (metrics.performance.averageLatency > this.config.latencyThreshold) {
      const alertId = 'high-latency';
      
      if (this.canTriggerAlert(alertId, now)) {
        const alert = this.createAlert(
          alertId,
          'performance',
          'warning',
          `High latency detected: ${metrics.performance.averageLatency.toFixed(2)}ms (threshold: ${this.config.latencyThreshold}ms)`,
          { 
            latency: metrics.performance.averageLatency,
            threshold: this.config.latencyThreshold 
          }
        );
        
        alerts.push(alert);
        this.setAlertCooldown(alertId, now);
      }
    } else {
      // „É¨„Ç§„ÉÜ„É≥„Ç∑„ÅåÊ≠£Â∏∏„Å´Êàª„Å£„ÅüÂ†¥Âêà„ÄÅÂØæÂøú„Åô„Çã„Ç¢„É©„Éº„Éà„Çí„ÇØ„É™„Ç¢
      this.clearAlert('high-latency');
    }
    
    // „Ç®„É©„ÉºÁéá„Ç¢„É©„Éº„Éà
    if (metrics.performance.errorRate > this.config.errorRateThreshold) {
      const alertId = 'high-error-rate';
      
      if (this.canTriggerAlert(alertId, now)) {
        const severity = metrics.performance.errorRate > this.config.errorRateThreshold * 2 ? 'critical' : 'warning';
        const alert = this.createAlert(
          alertId,
          'reliability',
          severity,
          `High error rate: ${metrics.performance.errorRate.toFixed(2)}% (threshold: ${this.config.errorRateThreshold}%)`,
          { 
            errorRate: metrics.performance.errorRate,
            threshold: this.config.errorRateThreshold 
          }
        );
        
        alerts.push(alert);
        this.setAlertCooldown(alertId, now);
      }
    } else {
      this.clearAlert('high-error-rate');
    }
    
    // Êé•Á∂öÂÆâÂÆöÊÄß„Ç¢„É©„Éº„Éà
    if (metrics.quality.connectionStability < this.config.connectionStabilityThreshold) {
      const alertId = 'connection-unstable';
      
      if (this.canTriggerAlert(alertId, now)) {
        const severity = metrics.quality.connectionStability < 50 ? 'critical' : 'warning';
        const alert = this.createAlert(
          alertId,
          'connection',
          severity,
          `Connection stability low: ${metrics.quality.connectionStability}% (threshold: ${this.config.connectionStabilityThreshold}%)`,
          { 
            stability: metrics.quality.connectionStability,
            threshold: this.config.connectionStabilityThreshold 
          }
        );
        
        alerts.push(alert);
        this.setAlertCooldown(alertId, now);
      }
    } else {
      this.clearAlert('connection-unstable');
    }
    
    // „Çπ„É´„Éº„Éó„ÉÉ„Éà„Ç¢„É©„Éº„Éà
    if (metrics.performance.throughput < this.config.throughputMinThreshold) {
      const alertId = 'low-throughput';
      
      if (this.canTriggerAlert(alertId, now)) {
        const alert = this.createAlert(
          alertId,
          'performance',
          'warning',
          `Low throughput: ${metrics.performance.throughput.toFixed(2)} msg/s (threshold: ${this.config.throughputMinThreshold} msg/s)`,
          { 
            throughput: metrics.performance.throughput,
            threshold: this.config.throughputMinThreshold 
          }
        );
        
        alerts.push(alert);
        this.setAlertCooldown(alertId, now);
      }
    } else {
      this.clearAlert('low-throughput');
    }
    
    // Êé•Á∂öÁä∂ÊÖã„Ç¢„É©„Éº„Éà
    if (metrics.connection.status !== 'connected') {
      const alertId = 'connection-not-connected';
      
      if (this.canTriggerAlert(alertId, now)) {
        const severity = metrics.connection.status === 'disconnected' ? 'critical' : 'warning';
        const alert = this.createAlert(
          alertId,
          'connection',
          severity,
          `Connection status is ${metrics.connection.status}`,
          { 
            status: metrics.connection.status 
          }
        );
        
        alerts.push(alert);
        this.setAlertCooldown(alertId, now);
      }
    } else {
      this.clearAlert('connection-not-connected');
    }
    
    // Á∑èÂêàÂìÅË≥™„Ç¢„É©„Éº„Éà
    if (metrics.quality.overallScore < 50) {
      const alertId = 'poor-quality';
      
      if (this.canTriggerAlert(alertId, now)) {
        const alert = this.createAlert(
          alertId,
          'system',
          'warning',
          `Poor overall quality: ${metrics.quality.overallScore}/100`,
          { 
            qualityScore: metrics.quality.overallScore 
          }
        );
        
        alerts.push(alert);
        this.setAlertCooldown(alertId, now);
      }
    } else {
      this.clearAlert('poor-quality');
    }
    
    // Áô∫Áîü„Åó„Åü„Ç¢„É©„Éº„Éà„Çí„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„É™„Çπ„Éà„Å´ËøΩÂä†
    alerts.forEach(alert => {
      this.activeAlerts.set(alert.id, alert);
      this.alertHistory.push(alert);
    });
    
    // Â±•Ê≠¥„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    this.cleanupAlertHistory();
    
    return alerts;
  }
  
  private createAlert(
    id: string,
    type: AlertType,
    severity: Alert['severity'],
    message: string,
    metrics: any
  ): Alert {
    return {
      id,
      type,
      severity,
      message,
      timestamp: new Date(),
      metrics,
      actions: this.generateAlertActions(id, type),
    };
  }
  
  private generateAlertActions(alertId: string, type: AlertType) {
    const actions = [];
    
    switch (type) {
      case 'connection':
        actions.push({
          id: 'reconnect',
          name: 'Reconnect',
          description: 'Attempt to reconnect WebSocket',
          handler: async () => {
            console.log('Triggering reconnection...');
            // ÂÆüÈöõ„ÅÆÂÜçÊé•Á∂ö„É≠„Ç∏„ÉÉ„ÇØ„ÇíÂÆüË£Ö
          },
        });
        break;
        
      case 'performance':
        actions.push({
          id: 'reduce_frequency',
          name: 'Reduce Message Frequency',
          description: 'Temporarily reduce message sending frequency',
          handler: async () => {
            console.log('Reducing message frequency...');
            // ÂÆüÈöõ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏È†ªÂ∫¶Ë™øÊï¥„É≠„Ç∏„ÉÉ„ÇØ„ÇíÂÆüË£Ö
          },
        });
        break;
        
      case 'reliability':
        actions.push({
          id: 'clear_queue',
          name: 'Clear Queue',
          description: 'Clear pending message queue',
          handler: async () => {
            console.log('Clearing message queue...');
            // ÂÆüÈöõ„ÅÆ„Ç≠„É•„Éº„ÇØ„É™„Ç¢„É≠„Ç∏„ÉÉ„ÇØ„ÇíÂÆüË£Ö
          },
        });
        break;
    }
    
    // ÂÖ±ÈÄö„Ç¢„ÇØ„Ç∑„Éß„É≥
    actions.push({
      id: 'acknowledge',
      name: 'Acknowledge',
      description: 'Acknowledge this alert',
      handler: async () => {
        this.clearAlert(alertId);
      },
    });
    
    return actions;
  }
  
  private canTriggerAlert(alertId: string, currentTime: number): boolean {
    const cooldownEnd = this.alertCooldowns.get(alertId);
    
    if (!cooldownEnd) {
      return true;
    }
    
    return currentTime >= cooldownEnd;
  }
  
  private setAlertCooldown(alertId: string, currentTime: number): void {
    const cooldownDuration = MONITORING_CONSTANTS.ALERT_DEBOUNCE_TIME;
    this.alertCooldowns.set(alertId, currentTime + cooldownDuration);
  }
  
  async sendAlert(alert: Alert): Promise<void> {
    console.log(`üö® WebSocket Alert [${alert.severity.toUpperCase()}]: ${alert.message}`);
    
    // Ë®≠ÂÆö„Åï„Çå„Åü„ÉÅ„É£„Éç„É´„Å´ÈÄöÁü•„ÇíÈÄÅ‰ø°
    for (const channel of this.config.notificationChannels) {
      try {
        await this.sendNotificationToChannel(alert, channel);
      } catch (error) {
        console.error(`Failed to send notification to ${channel}:`, error);
      }
    }
  }
  
  private async sendNotificationToChannel(alert: Alert, channel: NotificationChannel): Promise<void> {
    switch (channel) {
      case 'desktop':
        await this.sendDesktopNotification(alert);
        break;
        
      case 'log':
        this.logAlert(alert);
        break;
        
      case 'email':
        await this.sendEmailNotification(alert);
        break;
        
      case 'slack':
        await this.sendSlackNotification(alert);
        break;
        
      default:
        console.warn(`Unknown notification channel: ${channel}`);
    }
  }
  
  private async sendDesktopNotification(alert: Alert): Promise<void> {
    try {
      // macOS„ÅÆosascript„Çí‰ΩøÁî®„Åó„Å¶„Éá„Çπ„ÇØ„Éà„ÉÉ„ÉóÈÄöÁü•„ÇíÈÄÅ‰ø°
      const { exec } = require('child_process');
      const util = require('util');
      const execPromise = util.promisify(exec);
      
      const soundName = alert.severity === 'critical' ? 'Basso' : 'Glass';
      const command = `osascript -e 'display notification "${alert.message}" with title "WebSocket Monitor" subtitle "${alert.type} Alert" sound name "${soundName}"'`;
      
      await execPromise(command);
    } catch (error) {
      console.error('Failed to send desktop notification:', error);
    }
  }
  
  private logAlert(alert: Alert): void {
    const logLevel = alert.severity === 'critical' ? 'error' : 
                     alert.severity === 'warning' ? 'warn' : 'info';
    
    console[logLevel](`[${alert.timestamp.toISOString()}] WebSocket Alert - ${alert.type}: ${alert.message}`, alert.metrics);
  }
  
  private async sendEmailNotification(alert: Alert): Promise<void> {
    // „É°„Éº„É´ÈÄöÁü•„ÅÆÂÆüË£ÖÔºàÂÆüÈöõ„ÅÆ„É°„Éº„É´„Çµ„Éº„Éì„Çπ„Éó„É≠„Éê„Ç§„ÉÄ„Éº„Å´Âøú„Åò„Å¶ÂÆüË£ÖÔºâ
    console.log(`EMAIL: ${alert.message}`);
  }
  
  private async sendSlackNotification(alert: Alert): Promise<void> {
    // SlackÈÄöÁü•„ÅÆÂÆüË£ÖÔºàWebhook„ÇÑAPI„Çí‰ΩøÁî®Ôºâ
    console.log(`SLACK: ${alert.message}`);
  }
  
  configureAlerts(config: AlertConfig): void {
    this.config = { ...this.config, ...config };
    console.log('Alert configuration updated:', this.config);
  }
  
  getActiveAlerts(): Alert[] {
    return Array.from(this.activeAlerts.values());
  }
  
  clearAlert(alertId: string): void {
    if (this.activeAlerts.has(alertId)) {
      this.activeAlerts.delete(alertId);
      console.log(`Alert cleared: ${alertId}`);
    }
  }
  
  clearAllAlerts(): void {
    this.activeAlerts.clear();
    console.log('All alerts cleared');
  }
  
  getAlertHistory(limit?: number): Alert[] {
    const sortedHistory = [...this.alertHistory].sort(
      (a, b) => b.timestamp.getTime() - a.timestamp.getTime()
    );
    
    return limit ? sortedHistory.slice(0, limit) : sortedHistory;
  }
  
  private cleanupAlertHistory(): void {
    const maxHistorySize = 100;
    const retentionPeriod = 24 * 60 * 60 * 1000; // 24ÊôÇÈñì
    const cutoffTime = Date.now() - retentionPeriod;
    
    // Âè§„ÅÑ„Ç¢„É©„Éº„Éà„ÇíÂâäÈô§
    this.alertHistory = this.alertHistory.filter(
      alert => alert.timestamp.getTime() > cutoffTime
    );
    
    // Â±•Ê≠¥„Çµ„Ç§„Ç∫Âà∂Èôê
    if (this.alertHistory.length > maxHistorySize) {
      this.alertHistory = this.alertHistory
        .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
        .slice(0, maxHistorySize);
    }
  }
  
  getStatistics() {
    const now = Date.now();
    const last24h = now - (24 * 60 * 60 * 1000);
    
    const recent24hAlerts = this.alertHistory.filter(
      alert => alert.timestamp.getTime() > last24h
    );
    
    const alertsByType = new Map<AlertType, number>();
    const alertsBySeverity = new Map<Alert['severity'], number>();
    
    recent24hAlerts.forEach(alert => {
      // „Çø„Ç§„ÉóÂà•
      const typeCount = alertsByType.get(alert.type) || 0;
      alertsByType.set(alert.type, typeCount + 1);
      
      // ÈáçË¶ÅÂ∫¶Âà•
      const severityCount = alertsBySeverity.get(alert.severity) || 0;
      alertsBySeverity.set(alert.severity, severityCount + 1);
    });
    
    return {
      activeAlertsCount: this.activeAlerts.size,
      totalAlertsLast24h: recent24hAlerts.length,
      alertsByType: Object.fromEntries(alertsByType),
      alertsBySeverity: Object.fromEntries(alertsBySeverity),
      config: this.config,
    };
  }
  
  // „ÉÜ„Çπ„ÉàÁî®„ÅÆ„Ç¢„É©„Éº„ÉàÁô∫Áîü
  async triggerTestAlert(): Promise<void> {
    const testAlert = this.createAlert(
      'test-alert',
      'system',
      'info',
      'This is a test alert to verify the notification system',
      { test: true }
    );
    
    await this.sendAlert(testAlert);
  }
}